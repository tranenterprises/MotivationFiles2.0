// Supabase Edge Function for Daily Quote Generation
// Uses shared utilities for consistency and maintainability
import 'jsr:@supabase/functions-js/edge-runtime.d.ts';
import {
  generateDailyQuote,
  performHealthCheck,
  type DailyQuoteGenerationResult,
} from '../_shared/daily-quote-generator.ts';
import { 
  loadEdgeFunctionEnv, 
  createSecureHeaders 
} from '../_shared/env.ts';

// Enhanced security validation
function validateAuthorization(req: Request, cronSecret?: string): boolean {
  if (!cronSecret) {
    console.log('No CRON_SECRET configured - allowing request');
    return true; // Allow if no secret is configured
  }

  const authHeader = req.headers.get('authorization');
  if (!authHeader) {
    return false;
  }

  // Support multiple auth formats
  return (
    authHeader.includes(cronSecret) ||
    authHeader === `Bearer ${cronSecret}` ||
    authHeader === cronSecret
  );
}

// Main edge function handler
Deno.serve(async (req: Request) => {
  const startTime = Date.now();
  const requestId = crypto.randomUUID().substring(0, 8);
  const method = req.method;
  
  console.log(`[${requestId}] ${method} ${req.url} - Edge function triggered`);

  try {
    // Handle CORS preflight requests
    if (method === 'OPTIONS') {
      return new Response(null, {
        status: 200,
        headers: createSecureHeaders(),
      });
    }

    // Handle different HTTP methods
    if (method === 'GET' && req.url.includes('/health')) {
      // Health check endpoint
      console.log(`[${requestId}] Performing health check`);
      const healthResult = await performHealthCheck();
      
      const statusCode = healthResult.status === 'healthy' ? 200 :
                        healthResult.status === 'degraded' ? 200 : 503;
      
      return new Response(JSON.stringify({
        ...healthResult,
        requestId,
        timestamp: new Date().toISOString(),
      }), {
        status: statusCode,
        headers: createSecureHeaders({
          'X-Request-ID': requestId,
        }),
      });
    }

    // Main generation endpoint (POST or cron trigger)
    if (method !== 'POST' && method !== 'GET') {
      return new Response(JSON.stringify({
        success: false,
        error: 'Method not allowed',
        requestId,
      }), {
        status: 405,
        headers: createSecureHeaders({
          'Allow': 'GET, POST, OPTIONS',
          'X-Request-ID': requestId,
        }),
      });
    }

    // Enhanced security check
    const env = loadEdgeFunctionEnv();
    const isAuthorized = validateAuthorization(req, env.cronSecret);
    
    if (!isAuthorized) {
      console.log(`[${requestId}] Unauthorized request - invalid or missing credentials`);
      return new Response(JSON.stringify({
        success: false,
        error: 'Unauthorized',
        requestId,
      }), {
        status: 401,
        headers: createSecureHeaders({
          'X-Request-ID': requestId,
        }),
      });
    }

    // Parse request body for options (if POST)
    let options = {};
    if (method === 'POST' && req.body) {
      try {
        const body = await req.text();
        if (body.trim()) {
          options = JSON.parse(body);
        }
      } catch (error) {
        console.warn(`[${requestId}] Failed to parse request body:`, error);
        // Continue with empty options
      }
    }

    // Generate daily quote using shared utilities
    console.log(`[${requestId}] Starting daily quote generation...`);
    const result: DailyQuoteGenerationResult = await generateDailyQuote(options);
    
    const duration = Date.now() - startTime;
    console.log(`[${requestId}] Daily quote generation completed in ${duration}ms`);

    // Build response with metadata
    const response = {
      ...result,
      requestId,
      duration,
      timestamp: new Date().toISOString(),
      method,
    };

    return new Response(JSON.stringify(response), {
      status: result.success ? 200 : 500,
      headers: createSecureHeaders({
        'X-Request-ID': requestId,
      }),
    });

  } catch (error: any) {
    const duration = Date.now() - startTime;
    console.error(`[${requestId}] Edge function failed after ${duration}ms:`, {
      error: error.message,
      stack: error.stack,
      name: error.name,
    });

    // Determine if this is a retryable error
    const isRetryable = 
      error.message?.includes('timeout') ||
      error.message?.includes('network') ||
      error.message?.includes('connection') ||
      error.message?.includes('503') ||
      error.message?.includes('502') ||
      error.message?.includes('500');

    return new Response(JSON.stringify({
      success: false,
      error: 'Internal server error',
      details: error.message,
      retryable: isRetryable,
      requestId,
      duration,
      timestamp: new Date().toISOString(),
    }), {
      status: isRetryable ? 503 : 500,
      headers: createSecureHeaders({
        'X-Request-ID': requestId,
        ...(isRetryable && { 'Retry-After': '300' }), // Suggest retry after 5 minutes
      }),
    });
  }
});